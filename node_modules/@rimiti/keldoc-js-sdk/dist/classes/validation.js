"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _moment = _interopRequireDefault(require("moment"));

var _exceptions = require("./exceptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Validation =
/*#__PURE__*/
function () {
  function Validation() {
    _classCallCheck(this, Validation);
  }

  _createClass(Validation, null, [{
    key: "validateCreateAppointment",

    /**
     * @description Appointment validators.
     * @param params
     * @return {Promise<any>}
     */
    value: function validateCreateAppointment(params) {
      var requiredParams = ['start_at', 'agenda_id', 'state'];
      return Validation.validateMandatoryParams(requiredParams, params).then(function () {
        if (!Validation.datetimeFormat(params.start_at)) throw new _exceptions.InvalidDatetimeFormat();
      });
    }
    /**
     * @description Appointment validators.
     * @param params
     * @return {Promise<any>}
     */

  }, {
    key: "validateUpdateAppointment",
    value: function validateUpdateAppointment(params) {
      var requiredParams = ['start_at', 'agenda_id'];
      return Validation.validateMandatoryParams(requiredParams, params).then(function () {
        if (!Validation.datetimeFormat(params.start_at)) throw new _exceptions.InvalidDatetimeFormat();
      });
    }
    /**
     * @description Availabilities validators.
     * @param params
     * @return {Promise<any>}
     */

  }, {
    key: "validateFetchAvailabilities",
    value: function validateFetchAvailabilities(params) {
      var requiredParams = ['motive_id', 'start_date', 'end_date'];
      return Validation.validateMandatoryParams(requiredParams, params).then(function () {
        if (!Validation.datetimeFormat(params.start_date)) throw new _exceptions.InvalidDatetimeFormat();
        if (!Validation.datetimeFormat(params.end_date)) throw new _exceptions.InvalidDatetimeFormat();
      });
    }
    /**
     * @description Available slots validator.
     * @param params
     * @return {Promise<any>}
     */

  }, {
    key: "validateFetchAvailableSlots",
    value: function validateFetchAvailableSlots(params) {
      var requiredParams = ['agenda_id', 'start_date', 'end_date'];
      return Validation.validateMandatoryParams(requiredParams, params).then(function () {
        if (!Validation.datetimeFormat(params.start_date)) throw new _exceptions.InvalidDatetimeFormat();
        if (!Validation.datetimeFormat(params.end_date)) throw new _exceptions.InvalidDatetimeFormat();
      });
    }
    /**
     * @description Webhook validators.
     * @param params
     * @return {Promise<any>}
     */

  }, {
    key: "validateCreateWebhook",
    value: function validateCreateWebhook(params) {
      var requiredParams = ['url'];
      return Validation.validateMandatoryParams(requiredParams, params);
    }
    /**
     * @description Validate mandatory parameters.
     * @param mandatoryParams
     * @param requestObj
     * @return {Promise<any>}
     */

  }, {
    key: "validateMandatoryParams",
    value: function validateMandatoryParams(mandatoryParams, requestObj) {
      return new Promise(function (resolve) {
        var requestKeys = Object.keys(requestObj);
        var missingParams = mandatoryParams.filter(function (attribute) {
          return requestKeys.indexOf(attribute) < 0;
        });

        if (missingParams.length > 0) {
          throw new _exceptions.MissingMandatoryParameter("Parameter(s) ".concat(JSON.stringify(missingParams), " missing"));
        }

        resolve(true);
      });
    }
    /**
     * @description Check if datetime format is right.
     * @param datetime
     * @return {boolean}
     */

  }, {
    key: "datetimeFormat",
    value: function datetimeFormat(datetime) {
      return (0, _moment.default)(datetime, _moment.default.ISO_8601, true).isValid();
    }
  }]);

  return Validation;
}();

exports.default = Validation;